\chapter{Frameworks para proyectos de ciencia ciudadana}

\section{Frameworks} \label{sFrameworks}

	En esta sección se explorarán conceptos básicos de programación orientada a objetos como clases y herencia que son fundamentales para comprender qué es un framework.
 
	Las aplicaciones desarrolladas utilizando programación orientada a objetos están compuestas por una colección de objetos. Estos objetos poseen información sobre sí mismos y comportamiento, denominados atributos y métodos respectivamente. Para construir los objetos que componen la aplicación se utiliza un “molde” que se denomina clase \cite{weisfeld2008object}. Todos los objetos son instancias de una clase \cite{budd2008introduction}. 
 
	A modo de ejemplo se describe un sistema de gestión de pacientes para un consultorio. Se puede modelar una clase Paciente que tenga los atributos nombre, teléfono, correo electrónico, fecha de nacimiento, obra social y un método para agendar un turno. También se puede modelar una clase Médico que tenga los atributos nombre, teléfono, correo electrónico, fecha de nacimiento, matrícula y un método para emitir un turno. Las clases Médico y Paciente tienen atributos en común. Esto permite diseñar una clase Persona que contenga los atributos comunes (nombre, teléfono, fecha de nacimiento) y que las clases Paciente y Médico hereden de la clase Persona y definan sus atributos particulares (obra social en el caso de la clase Paciente y matrícula en la clase Médico). 
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.4]{04-framework/personaAtributosMetodos.png}
		\caption{Atributos y Métodos de la clase Persona}
		\label{fig:umlClassAttributesMethods}
	\end{figure}
	
	Ampliando el ejemplo, se requiere que los médicos y los pacientes puedan ser contactados.
Pero a los pacientes se los puede contactar por correo electrónico ya que la comunicación nunca es urgente. En cambio a los médicos se los debe contactar por teléfono. Para cumplir con este requerimiento, se agrega en la clase Persona un método abstracto ‘contactar()’ que no tiene implementación ya que el comportamiento debe ser implementado en las clases que heredan de ella. 

\begin{figure}[H]
		\centering
		\includegraphics[scale=0.4]{04-framework/personaMetodoAbstracto.png}
		\caption{Método abstracto en clase Persona}
		\label{fig:umlClassAttributesMethods}
	\end{figure}
	
La clase Persona es ahora una clase abstracta ya que contienen uno o más métodos para los cuáles no provee una implementación \cite{weisfeld2008object}. 
 
Las clases pueden agruparse en librerías para ser reutilizadas en otro proyecto. De esta manera, los componentes se van sumando para crear librerías más complejas que en conjunto con otros componentes reutilizables, diseños, patrones de diseño y estructuras que definen comportamiento logran ser una aplicación a la que sólo le falta la definición propia del dominio en el que se está implementando.
 
Un framework es una aplicación reutilizable, semi-completa que puede ser especializada para producir aplicaciones a medida \cite{fayad1997object}. También puede verse como un esqueleto que puede ser configurado por un desarrollador para construir una aplicación \cite{johnson1997frameworks}.   
 
Los frameworks se desarrollan teniendo como objetivo un área en particular y un dominio de aplicación específico \cite{fayad1997object}. Un framework diseñado para gestionar la agenda de un consultorio médico probablemente permita ser adaptada para gestionar la agenda de otro tipo de consultorio de salud (un consultorio odontológico o psicológico) ya que ambos ámbitos de aplicación comparten la gestión de pacientes y médicos. Pero en el caso de querer desarrollar una aplicación para gestionar muestras de un relevamiento para una investigación científica debe investigarse un framework que se adapte mejor.
		
Diseñar un framework requiere experiencia y experimentación al igual que lo requiere el diseño de las clases abstractas de sus componentes.\cite{johnson1988designing} 


\subsection{Tipos de Frameworks}

	Como se mencionó en la sección anterior \ref{sFrameworks}, los frameworks son específicos de un dominio de aplicación. Pueden clasificarse de varias maneras dependiendo de si son para construir servicios, interfaces de usuario o aplicaciones. También pueden clasificarse por la manera en que permiten la especialización. Los frameworks de caja blanca son aquellos que utilizan la herencia y la extensión de métodos. Estos frameworks permiten conocer los estados internos de las clases que lo componen. Los frameworks denominados de caja negra utilizan la composición para permitir la especialización. El desarrollador no tiene acceso al estado interno de las clases del framework ni puede extender o agregar métodos. La especialización se realiza proveyendo un componente que respeta un protocolo (o API) de interacción con el framework para lograr el comportamiento específico.   

\subsubsection{Frameworks de caja blanca}

	Una de las características importantes de un framework es que los métodos definidos por el usuario para extender el comportamiento van a ser invocados desde el interior del framework más que del código de la aplicación del usuario. A menudo hace las veces de programa principal coordinando y secuenciando las actividades de la aplicación. Esa inversión de control le permite al framework servir como esqueleto extensible. El código brindado por los usuarios en los métodos extienden el algoritmo genérico del framework para una aplicación en particular. 
	
	Si el comportamiento específico de una aplicación que utiliza un framework se define agregando métodos a las subclases o a una o más de sus clases, el framework es denominado de Caja Blanca (white-box). Cada método que se agrega a una subclase debe continuar con las convenciones internas que adoptan las superclases. 
	
	El principal problema de los frameworks de caja blanca es que cada aplicación requiere la creación de una numerosa cantidad  de subclases. Y aunque muchas de estas subclases creadas son simples, es su número lo que para un desarrollador con poca experiencia puede volver difícil comprender el diseño de una aplicación lo suficiente como para modificarla.
	
	Un segundo problema es que un framework de caja blanca puede ser difícil de aprender a utilizar, ya que entender cómo se utliza es lo mismo que entender cómo está construido.\cite{johnson1988designing}
	
\subsubsection{Frameworks de caja negra}

	Otra manera de especializar un framework es incluir en él un conjunto de componentes que sean los que proveen el comportamiento específico de la aplicación. Cada uno de estos componentes debe entender un protocolo en particular. Todos o la mayoría de los componentes pueden tomarse de una librería de componentes. La interfaz entre componentes pueden ser definidas con un protocolo, de esta manera el usuario sólo necesita entender la interfaz externa de los mismos. Este tipo de framework se denomina de caja negra.
	
	Los frameworks de caja negra son más fáciles de aprender a utilizar que los de caja blanca, pero son menos flexibles. 
	
	Una manera de caracterizar la diferencia entre un framework de caja blanca y uno de caja negra es observar que en el de caja blanca el estado de cada instancia está disponible de manera implícita en todos los métodos del framework, casi como las variables globales de Pascal. En un framework de caja negra, cualquier información que se pase a las partes constituyentes del framework debe pasarse de manera explícita. Un framework de caja blanca utiliza las reglas de alcance intra-objeto para evolucionar sin forzarlo a subscribirse a un protocolo explícito que podría restringir de manera prematura el proceso de diseño.
 \cite{johnson1988designing}


\section{Estado del arte} \label{sec:estado_arte}
Luego de detallar los aspectos conceptuales de los frameworks con respecto a su arquitectura y con respecto a la manera en la que permiten la especialización, en esta sección se exploran seis herramientas, entre plataformas y frameworks, que permiten generar aplicaciones que sirvan de soporte a los proyectos de recolección de ciencia ciudadana. 

\begin{comment}
Los dispositivos móviles son ideales para que las personas puedan de manera espontánea recolectar información. Sin embargo, esa simplicidad yace sobre una base que requiere fuertes conocimientos técnicos y una infraestructura compleja. Por lo tanto, construir aplicaciones móviles implican una inversión que puede ser limitante para organizaciones pequeñas. A continuación se analizan algunas alternativas que permiten que personas que no son desarrolladoras tengan la posibilidad de crear herramientas que permitan la recolección de información para proyectos de ciencia ciudadana con dispositivos móviles. \cite{kim2013sensr}
\end{comment}


\subsection{Sensr}


Sensr \cite{kim2013sensr} es una herramienta que permite que interesados sin conocimientos de programación
puedan crear aplicaciones para dispositivos móviles que faciliten la recolección de información para ciencia ciudadana. 

La documentación que acompaña la herramienta explica las ventajas que los dispositivos móviles poseen para recolectar de manera espontánea información del entorno, pero también advierte que bajo esta simplicidad existe una complejidad técnica y de infraestructura a la hora de desarrollar este tipo de aplicaciones. Contrasta la facilidad de utilización de un dispositivo móvil con la complejidad que el desarrollo de aplicaciones para estos dispositivos representa. Los desarrolladores de aplicaciones móviles tienen la posibilidad de usar directamente el hardware y los sensores que brindan estos dispositivos. 
Sensr es un framework que consiste de dos partes:
Una parte es un sitio web alojado en Amazon Web Services donde los interesados pueden crear y administrar campañas y donde el público puede acceder a la lista de campañas activas junto con visualización de información. La otra parte es una aplicación móvil con la que los voluntarios pueden explorar, suscribir y/o participar en campañas.


\subsection{Project Noah}
Project Noah \cite{projectNoah} es una comunidad global para compartir fotos de avistajes de fauna en su hábitat natural. A medida que se comparten fotos, el usuario miembro de la comunidad, empieza a plasmar sus registros de la naturaleza igual que lo haría en un diario o jornal de viaje. 
Permite el registro particular generando un usuario con correo electrónico y contraseña, y también permite el inicio de sesión por integración a servicios de autenticación como los brindados por Google o con redes sociales.
Una vez que se accede con un usuario se pueden ingresar avistajes completando un formulario y agregando una o varias fotografías del avistaje. Entre la información requerida se encuentran geolocalización, fecha, nombre científico (si se conoce), información adicional que se quiera agregar o que no haya sido capturada en la o las imágenes, una descripción del habitat y otras notas. 
Project Noah permite participar de ‘Misiones’ que son lo que en Sensr serían campañas: compartir fotos de avistajes con determinadas características. Una misión, por ejemplo, tiene por título ``Aves del Mundo“. Se puede unir a esa misión y cuando se registre un nuevo avistaje se puede seleccionar la opción de agregarlo a la galería de esa misión. También permite aportar en avistajes de otros miembros de la comunidad observaciones propias o bien sugerir una identificación del ejemplar del avistaje.
La comunidad tiene miembros que son diferentes al usuario estándar. Se denominan «Rangers» y son los que se encargan de sugerir identificación de especies de otros avistajes, de dar la bienvenida a los nuevos miembros y de compartir avistajes de manera más regular. 

\subsection{EpiCollect}
Epicollect \cite{epicollect} es una aplicación web y aplicación móvil gratuita y fácil de utilizar para recolectar información. Los proyectos se crean utilizando el sitio web y luego se descarga una app a un dispositivo móvil para efectuar la recolección de información. 
La información (incluyendo GPS y multimedia) puede ser recolectada utilizando múltiples dispositivos y puede ser vista en un servidor central (utilizando mapas, tablas y gráficos).
También puede ser exportada en formato cvs y json.
La aplicación móvil está disponible para Android (6+) y iOS (12+)

Los usuarios pueden ingresar a la aplicación con su cuenta de Google, su cuenta de Apple o bien creando una cuenta con su correo electrónico. Para crear un proyecto se debe ingresar el nombre, una descripción, seleccionar el tipo de acceso entre público (cualquier usuario puede colaborar) o privado (sólo usuarios seleccionados por el administrador del proyecto pueden colaborar) y definir como mínimo un formulario para recolectar la información. Permite toda una variedad de ``preguntas“ que pueden ser de tipo texto, numérico, telefóno, foto, video, código de barras y varios tipos más entre los disponibles. Cada formulario de pregunta tiene una opción para conectar a la siguiente pregunta que permite formato condicional, es decir, en caso de que la respuesta cumpla determinadas condiciones se ejecuta un ``salto“ a un formulario determinado. En la edición del proyecto, permite modificar el tipo de acceso nuevamente, el estado, la visibilidad y permite asignarle una categoría entre las predefinidas.
La información de las entradas de los usuarios se puede visualizar en una tabla, en un mapa o descargarse.

\subsection{CitSci}
CitSci.org \cite{citsci} se define como una plataforma global para soporte para la Ciencia Ciudadana. La aplicación web CitSci permite que un usuario registrado cree un proyecto de Ciencia Ciudadana definiendolo con un título, una descripción breve de qué consiste el proyecto, sus objetivos y tareas. Esta información la utiliza como portada de presentación del proyecto. También permite definir si la colaboración va a ser pública o privada. Si la colaboración es pública, con que un usuario registrado quiera unirse y registrar observaciones alcanza. En el caso de la colaboración privada, los usuarios deben solicitarle al administrador del proyecto su permiso para unirse y aportar la información que recolectan. La visibilidad del proyecto también puede ser pública y salir en la lista de proyectos de la plataforma, o puede ser privada y no salir en el listado. Permite integrar con Zooniverse para el procesamiento de imágenes y permite agregar material relacionado como pueden ser documentos que amplíen la información de los objetivos, o la recolección de muestras, así como recursos gráficos y cualquier material extra que quiera anexarse.
Una vez creado un proyecto de ciencia ciudadana, para que los colaboradores pueden ingresar información debe definirse una plantilla con las opciones de recolección disponibles. La plantilla debe tener un nombre, instrucciones de la actividad que debe realizar el ciudadano científico, el formato de fecha y el formato de geolocalización que puede ser latitud y longitud, recorrido o ambas. Una vez determinada esta información básica y obligatoria, se pueden agregar otras opciones al formulario de recolección de información que pueden ser:
			\begin{itemize}
				\item Imagen
				\item Fecha/Hora
				\item Número
				\item Título
				\item Opción Simple - selección de una opción (radio button)
				\item Lista Desplegable - Selección de una opción mediante lista desplegable
				\item Texto
				\item Organismo 
			\end{itemize}
Cada una de estas opciones permiten su configuración particular. Por ejemplo, la opción Lista Desplegable permite definir un título, una ayuda en forma de pista que aparece, los items que componen la lista y si es opcional u obligatoria. Por cada una de las opciones que se agreguen a la recolección de la muestra la aplicación móvil genera un paso para que el ciudadano científico complete. Las plantillas definidas pueden modificarse y también pueden definirse otras plantillas de recolección de muestras.					 
Una vez definidas las opciones requeridas para la recolectar una muestra, la información puede ingresarse por la aplicación web, o puede descargarse la aplicación móvil que provee CitSci para Android o Ios. La aplicación móvil permite que el científico ciudadano se una a los proyectos publicados o recolecte muestras en los proyectos que creó o a los que se unió. Las muestras que recolecta quedan en un listado de muestras donde por cada una tiene disponibles las acciones de editar, eliminar o subir la información a la plataforma.  		
La plataforma brinda una herramienta que permite administrar las muestras recolectadas, listarlas y por cada una de ellas visualizarlas, editarlas o eliminarlas. También provee un foro asociado al proyecto. 	

\subsection{Spotteron}		

Spotteron \cite{spotteron} provee Aplicaciones y Servicios de Ciencia Ciudadana para proyectos científicos e instituciones. Su equipo de desarrollo se enfoca en el diseño, el profesionalismo técnico, la confiabilidad y la interacción con el usuario. Este equipo se especializa en crear soluciones a medida para Ciencia Ciudadana que incluyen aplicaciones móviles, sitio web y herramientas para el Análisis y la Visualización de la información. 

Ofrecen, en conjunto con la plataforma Spotteron para la Ciencia Ciudadana un sistema de aplicaciones personalizables y económicamente accesibles, aplicables en áreas de la Ciencia Ciudadana, de protección ambiental y monitoreo de voluntarios. Desarrollan aplicaciones móviles independientes en Ios y Android, aplicaciones web interactivas como mapas o juegos para ciencia ciudadana y proveen una plataforma estable y confiable para los mismos.

El objetivo es proveer un sistema con mantenimiento y mejoras constantes y un servicio profesional y confiable para la Ciencia Ciudadana, para la Conservación del Medio Ambiente y Proyectos Sociales. También considerar a los usuarios y albergar el crecimiento de la comunidad y fomentar la interacción entre ciudadanos y científicos.

\subsection{Zooniverse}	

Zooniverse \cite{Zooniverse} es la más grande y popular plataforma de ciencia ciudadana para investigaciones científicas. El objetivo de Zooniverse es llevar a cabo investigaciones  que no serían posibles o prácticas de otra manera. Aunque Zooniverse opera sobre todo en su aplicación web \cite{zooniverseMobile} también provee una aplicación móvil para que los científicos ciudadanos puedan hacer su colaboración desde sus dispositivos móviles. 
La plataforma provee una herramienta de construcción de proyectos, Project Builder, que permite configurar tres secciones de los proyectos de investigación

			\begin{itemize}
				\item { Proyecto (Project) } 
				
				Galaxy Zoo, un proyecto que vive en la plataforma desde hace más de diez años, es un buen ejemplo de proyecto que puede construirse utilizando la herramienta Project Builder. En este proyecto los científicos ciudadanos clasifican galaxias de acuerdo a su forma observando fotografías del espacio y dibujando digitalmente sobre ellas. Un proyecto tiene nombre, descripción, un avatar (una imagen que lo identifica), colaboradores y otros atributos configurables más.
				
				\item { Secuencia de Tareas (Workflows) } 
				Workflow es la secuencia de tareas que deben realizar los científicos ciudadanos. Un workflow tiene un título que sirve para identificarlo, un número de versión que se utiliza para trazar los cambios y tareas que pueden ser de tres tipos:  responder preguntas, transcribir o dibujar.  
				
				\begin{itemize}
				
				\item { Pregunta }  
				Las tareas de tipo pregunta pueden ser preguntas de única respuesta o de respuesta múltiple. Las preguntas pueden marcarse como ‘requeridas’ y en este caso el científico ciudadano no puede avanzar hacia la siguiente tarea hasta no haber ingresado una respuesta.
				
				\item { Dibujar }  
				Las tareas de este tipo requieren que el científico ciudadano marque o dibuje de manera digital sobre una muestra del conjunto de muestras definido. La marca o dibujo que realice va a terminar siendo de un tipo entre los predefinidos (forma libre, rectángulo, elipse, círculo y otros disponibles) y será para señalar alguna cosa en la muestra que se está analizando. La herramienta dibujo permite ingresar también etiquetas o color aparte del marcado en sí.
				
				\item { Transcripción }  
				Las tareas de transcripción requieren que los científicos ciudadanos transcriban una porción de texto que perciben en un archivo multimedia. Puede solicitarse una transcripción fiel que respete la ortografía original o bien una que modernice y corrija el texto original. Las herramientas de transcripción también permiten marcar o hacer una lista de palabras clave asociadas al texto o porción de texto que se está analizando.
				\end{itemize}
				
				Una vez definidas las tareas se está en condiciones de definir el workflow. Una de esas tareas se marca como ‘Primer Tarea’. Luego, utilizando un selector de opciones se configura que tarea de las definidas será la siguiente. En las tareas de tipo ‘pregunta’ se puede especificar una tarea distinta para cada respuesta disponible. 
La secuencia de tareas que cumplen determinadas condiciones se pueden habilitar para estar disponibles desde la aplicación móvil que provee Zooniverse y permitir que los científicos ciudadanos colaboren desde sus dispositivos. Diseñar un workflow que se puede habilitar para la aplicación móvil permite incrementar la cantidad de colaboraciones que recibe el proyecto.				
				
				\item { Conjunto de Muestras (Subject Set) } 
				Un conjunto de muestras es un grupo de datos que debe ser clasificado. Consiste generalmente de archivos multimedia como imágenes, archivos de sonido o videos, sobre los cuáles los científicos ciudadanos deben marcar cosas que perciban. Se puede tener un conjunto de muestras sobre el que se pueden seguir agregando muestras a lo largo del tiempo, o varios de diferentes momentos o lugares. Se pueden tener diferentes conjuntos de muestras para diferentes secuencias de tareas aunque no es necesario. 
				
			\end{itemize}	


\subsection{Conclusión}
La herramienta Sensr permite desarrollar una campaña de recolección de información más una aplicación móvil para que los científicos ciudadanos que quieran participar de una campaña puedan hacerlo mediante esa aplicación. El autor de la campaña, completando formularios en el sitio web y arrastrando componentes para definir el contenido y las validaciones, diseña la aplicación móvil que se generará. Esta aplicación móvil sólo está disponible para dispositivos con sistema operativo iOS y la administración de la información se puede realizar sólo a través del sitio web. Al no ser iOS el sistema operativo más popular entre los usuarios de dispositivos móviles de Argentina, como se mencionó en la sección \ref{ccDispMoviles}, es una alternativa con menos alcance que la que proponemos. 
Project Noah podría calificar como herramienta social para colaborar con la Ciencia Ciudadana. La posibilidad de compartir avistajes a través de las redes sociales, puede llegar a más interesados que quieran formar parte de esta comunidad o puede poner en contacto a personas interesadas en la vida al aire libre.
Aunque asiste de manera intuitiva, el ingreso de la información de geolocalización del avistaje es en forma de coordenadas, latitud y longitud. Si un usuario quisiera subir varios avistajes de un viaje, debería recordar dónde hizo cada uno y señalarlos en un mapa. También está limitado al avistaje de fauna.
Epicollect es una herramienta simple e intuitiva para construir proyectos de recolección de información mediante cuestionarios. El proyecto está financiado por Wellcome Trust Foundation y está implementado con tecnologías open source. Ofrece una API para desarrolladores que permite consultar la información mediante servicios o integrar los cuestionarios a una app propia, previo registro de la aplicación en el proyecto Epicollect. Epicollect siempre está intermediando entre los científicos ciudadanos y los administradores del proyecto. Las herramientas que ofrece, las ofrece siempre a través de la plataforma. CitSci permite implementar proyectos de recolección de ciencia ciudadana de manera sencilla y se integra con Zooniverse y con SciStarter, lo que permite diversificar las muestras y los colaboradores. La aplicación móvil que ofrece es propia y compartida entre todos los proyectos que conviven en la plataforma.  No permite personalizar muchas características del proyecto más allá de la foto de portada. 
Spotteron es un equipo y una plataforma que está ampliamente utilizada sobre todo en Europa. El equipo que hace el desarrollo y mantenimiento de las aplicaciones está integrado por profesionales con experiencia en áreas como marketing y desarrollo. De esta manera el equipo puede brindar servicios y soporte  a precios accesibles. No se integran a otras aplicaciones de Ciencia Ciudadana ni proveen API's de integración.
Zooniverse brinda herramientas que permiten realizar una configuración exhaustiva de un proyecto. Aunque posee más riqueza que las otras herramientas exploradas en cuanto a definición de tareas y secuencia de las mismas, su aplicación móvil también es compartida entre los proyectos, de la misma manera que ofrece CitSci. 


\begin{comment}

http://www.sensr.org/

https://publicparticipationinscience.files.wordpress.com/2015/07/sensr.pdf

	Los dispositivos móviles son ideales para que las personas puedan de manera espontánea recolectar información. Sin embargo, esa simplicidad yace sobre una base que requiere fuertes conocimientos técnicos una infraestructura compleja. Por lo tanto, construir aplicaciones móviles implican una inversión que puede ser limitante para organizaciones pequeñas. Sensr es una herramienta que permite que personas que no son desarrolladoras tengan la posibilidad de crear herramientas que permitan la recolección de información para proyectos de ciencia ciudadana con dispositivos móviles. Esta herramienta aprovecha que el proceso y la estructura de la información en las actividades de recolección de datos de los proyectos de ciencia ciudadana son similares independientemente del dominio o la diversidad de los mismos. Sensr combina un ambiente de programación gráfico con una aplicación móvil para que las personas que no necesariamente poseen conocimientos técnicos puedan construir herramientas de recolección de información para dispositivos móviles y administrar la información recabada de manera colectiva.
	
	De esta manera, una persona que necesita reunir información puede ser el autor de una campaña de ciencia ciudadana en el sitio de Sensr. La campaña es desplegada en la aplicación móvil de Sensr, y sus usuarios se pueden suscribir y contribuir a la campaña con los datos recolectados. Esta herramienta pretende simplificar de manera radical el proceso de crear una herramienta para dispositivos móviles que permita recolectar información y que sea de utilidad en una amplio conjunto de dominios de ciencia ciudadana. Los autores sólo necesitarían completar la descripción del proyecto y diseñar las plantillas o formularios que permitan el ingreso de los datos antes de incluir su proyecto en Sensr y ser distribuido de forma masiva. De esta manera, los autores se liberarían de las preocupaciones acerca de los requerimientos técnicos y las restricciones de la infraestructura.
	
	La falta de expertos técnicos y de recursos son a menudo los mayores obstáculos a la hora de desarrollar una aplicación móvil. Los grupos que quieren desarrollar una aplicación móvil de ciencia ciudadana a menudo son organizaciones sin fines de lucro o pequeñas organizaciones regionales que no poseen ni los recursos económicos ni los expertos técnicos que necesitan para desarrollar o mantener ese tipo de aplicaciones. Y además de la programación en si, la administración de los datos recolectados también representan un desafío, ya que estas mismas organizaciones tampoco poseen los servidores para almacenar o analizar el volumen de datos que puedan ser recolectados. El monitoreo participativo es un paradigma computacional que permite la recolección por parte de los voluntarios de información que se encuentra diseminada. Permite que el creciente número de usuarios de teléfonos móviles puedan compartir la información adquirida mediante los sensores de sus dispositivos en variados dominios. 
	
	Los investigadores han explorado la utilización de plataformas existentes como una alternativa para Y aunque varias de ellas son robustas y flexibles, la mayoría necesita de habilidad para programar y/o conocimiento de infraestructura en mayor o menor medida. Aunque por ejemplo el Proyecto Noah y EpiCollect son dos ejemplos claros de plataformas que soportan autoría de aplicaciones sin necesidad de programación. \cite{kim2013sensr}
	
\end{comment}




\chapter{El entorno de Android}

Android es un sistema operativo móvil desarrollado por Google, basado en Kernel de Linux. Está pensado para diferentes dispositivos móviles con pantalla táctil como teléfonos inteligentes, tablets, relojes inteligentes (Wear OS), automóviles (Android Auto) y televisores (Android TV).

Inicialmente fue desarrollado por Android Inc., adquirido por Google en 2005 y presentado en 2007 junto con la fundación del Open Handset Alliance (un consorcio de compañías de hardware, software y telecomunicaciones) para avanzar en los estándares abiertos de los dispositivos móviles. El código fuente principal de Android se conoce como Android Open Source Project (AOSP), que se licencia principalmente bajo la Licencia Apache. 

Para escribir aplicaciones (app) para Android, se pueden usar los lenguajes Java, Kotlin y C++. Las herramientas de Android SDK compilan el código, junto con los archivos de recursos y datos, en un APK: un paquete de Android, que es un archivo de almacenamiento con el sufijo .apk. Un archivo APK incluye todos los contenidos de una app de Android y es el archivo que usan los dispositivos con tecnología Android para instalar la app.

Cada app de Android reside en su propio entorno aislado de seguridad y está protegida por las siguientes características de seguridad de Android:
\begin{itemize}
	\item El sistema operativo Android es un sistema Linux multiusuario en el que cada app es un usuario diferente.
	\item De forma predeterminada, el sistema le asigna a cada app un ID de usuario de Linux único (solo el sistema utiliza el ID y la app lo desconoce). El sistema establece permisos para todos los archivos en una app de modo que solo el ID de usuario asignado a esa app pueda acceder a ellos.
	\item Cada proceso tiene su propia máquina virtual (VM), por lo que el código de una app se ejecuta de forma independiente de otras apps.
	\item De forma predeterminada, cada app ejecuta su propio proceso de Linux. El sistema Android inicia el proceso cuando se requiere la ejecución de alguno de los componentes de la app y, luego, lo cierra cuando el proceso ya no es necesario o cuando el sistema debe recuperar memoria para otras apps.
\end{itemize}

De esta manera, el sistema Android implementa el principio de mínimo privilegio. Es decir, de forma predeterminada, cada app tiene acceso solo a los componentes que necesita para llevar a cabo su trabajo y nada más. Esto crea un entorno muy seguro, en el que una app no puede acceder a partes del sistema para las que no tiene permiso. Sin embargo, hay maneras en las que una app puede compartir datos con otras apps y en las que puede acceder a servicios del sistema solicitando permiso para acceder a datos del dispositivo, como los contactos de un usuario, los mensajes de texto, el dispositivo de almacenamiento (tarjeta SD), la cámara, la conexión Bluetooth, etc. El usuario debe conceder de manera explícita estos permisos.

Una app en Android esta compuesta por uno o varios componentes de app. Los componentes de app son los bloques de compilación fundamentales, y cada uno es un punto de entrada a través del cual el sistema o un usuario puede entrar a la app. Algunos dependen unos de otros y hay 4 tipos diferentes de componentes de app. Cada tipo sirve para diferentes propósitos y tienen diferentes ciclos de vida que definen como se crea y destruye el componente. Los 4 tipos de componentes de app son:

\begin{itemize}
	\item \textbf{Activities:} Una Activity es un punto de entrada para interactuar con el usuario. Representa una simple pantalla con interfaz de usuario.
	
	\item \textbf{Services:} Un Service es un punto de entrada de propósito general para mantener una app corriendo en segundo plano por múltiples razones. Es un componente que corre en segundo plano para realizar operaciones de larga duración o procesar trabajos para un proceso remoto. Un Service no proporciona una interfaz de usuario.
	
	\item \textbf{BroadcastReceivers:} Un BroadcastReceiver es un componente que habilita al sistema a entregar eventos a una app fuera del flujo de usuario habitual, permitiendo a la app responder a una gran variedad de anuncios del sistema. Como los BroadcastReceivers son otro punto de entrada a una app, el sistema puede entregar eventos de difusión a apps que incluso no se estén ejecutando en ese momento.
	
	
	\item \textbf{ContentProviders:} Un ContentProvider administra un conjunto de datos de la app que se pueden compartir y que se almacenan en el sistema de archivos, en una base de datos SQLite, en la web, o en cualquier otro almacenamiento persistente. A través del ContentProvider, otras apps pueden consultar o modificar los datos si el ContentProvider lo permite.
	
	
\end{itemize}

Más adelante se explican con más detalle los componentes que influyeron en el desarrollo de Samplers.

Un aspecto único del diseño del sistema Android es que cualquier app puede iniciar un componente de otra app (por medio de una petición al sistema). Por ejemplo, si se desea tomar una foto con la cámara del dispositivo, seguramente ya hay otra app que lo hace, y se puede llamar a esa app en lugar de desarrollar una Activity que tome una foto.
\cite{androidDocs}

\section{Activities}
La clase Activity es un componente clave de una app para Android, y la forma en que se inician y se crean las Activities es una parte fundamental del modelo de aplicación de la plataforma. A diferencia de los paradigmas de programación en los que las apps se inician con un método main(), el sistema Android inicia el código en una instancia de Activity invocando métodos de devolución de llamada específicos que corresponden a etapas específicas de su ciclo de vida. 

La experiencia con la app para dispositivos móviles difiere de la versión de escritorio, ya que la interacción del usuario con la app no siempre comienza en el mismo lugar. En este caso, no hay un lugar específico desde donde el usuario comienza su actividad. Por ejemplo, si abres una app de correo electrónico desde la pantalla principal, es posible que veas una lista de correos electrónicos. Por el contrario, si usas una app de redes sociales que luego inicia tu app de correo electrónico, es posible que accedas directamente a la pantalla de la app de correo electrónico para redactar uno.

La clase Activity está diseñada para facilitar este paradigma y se debe heredar de ella para implementar las Activities de una app. 

Cuando una app invoca a otra, la app que realiza la llamada invoca una Activity en la otra, en lugar de a la app en sí. De esta manera, la Activity sirve como el punto de entrada para la interacción de una app con el usuario

Una Activity proporciona la ventana en la que la app dibuja su interfaz de usuario (IU). Por lo general, esta ventana llena la pantalla, pero puede ser más pequeña y flotar sobre otras ventanas. Generalmente, una Activity implementa una pantalla en una app. Por ejemplo, una Activity de una app puede implementar una pantalla Preferencias mientras otra implementa una pantalla Seleccionar foto. 

Cada Activity administra su propio diseño, que se carga desde un archivo XML en donde se definen los diferentes elementos de diseño (existen herramientas en las que se puede definir el diseño visualmente y éste se traduce al formato XML). Un diseño define la estructura de una interfaz de usuario que está compuesto por una jerarquía de objetos View y ViewGroup. Una View suele mostrar un elemento que el usuario puede ver y con el que puede interactuar; suelen llamarse 'widgets' y pueden ser una de las muchas subclases, como Button (que muestra un botón) o TextView (que muestra un texto). Por su parte, ViewGroup es un contenedor invisible que define la estructura de diseño de View y otros objetos ViewGroup; se denominan generalmente 'layouts'  y pueden ser de muchos tipos que proporcionan una estructura diferente, como LinearLayout (que posiciona los elementos de forma linear, ya sea horizontal o verticalmente) o RelativeLayout (que posiciona los elementos en relación a otros elementos o a los bordes de la pantalla).
También se puede crear el diseño de una Activity declarando instancias de elementos de diseño en tiempo de ejecución.

El sistema Android administra las Activities como una pila (stack\footnote{Stack en inglés, una lista ordenada con acceso a sus elementos de tipo «último en entrar, primero en salir»}). Cuando se crea una nueva Activity, esta es puesta en la cima de la pila actual y se convierte en la Activity actual; la Activity anterior siempre permanece abajo en la pila, y no vuelve a estar en primer plano de nuevo hasta que la nueva Activity finalice, y puede haber una o muchas Activities en la pila.
Es por esto que a lo largo de su vida útil, una Activity pasa por varios estados. Para administrar las transiciones entre estados, se deben usar una serie de devoluciones de llamadas.

Una Activity tiene básicamente cuatro estados:

\begin{itemize}
	\item Si una Activity esta en primer plano de la pantalla (en la posición más alta de la pila) está en estado 'activa' o 'running'. Es generalmente la Activity con la que el usuario está interactuando.
	\item Si una Activity ha perdido el foco pero todavía se muestra al usuario, entonces está en estado 'visible'. Esto sucede por ejemplo cuando hay otra Activity encima pero que no cubre toda la pantalla. La Activity en este estado esta completamente 'viva' (conserva todos sus estados e información y se mantiene vigente para el administrador de ventanas).
	\item Si una Activity esta cubierta completamente por otra, entonces esta en estado 'detenida' u 'oculta'. Aún conserva todos sus estados e información, pero ya no es visible al usuario por lo que su ventana esta oculta, y podría ser destruida por el sistema si se necesita memoria para otro propósito.
	\item El sistema puede bajar de la memoria a la Activity solicitándole que finalice, o simplemente destruyendo su proceso, pasándola al estado 'destruida'. Cuando se necesita mostrarla al usuario de nuevo, la Activity debe ser restaurada completamente y se debe restaurar su estado anterior.
\end{itemize}

El siguiente diagrama muestra los estados más importantes por los que pasa una Activity. Los rectángulos representan métodos de respuesta a llamada que se pueden implementar para realizar operaciones cuando la Activity se mueve entre un estado y otro. Los óvalos representan los estados más importantes por los que pasa una Activity.
\cite{androidDocs}

\begin{figure}[H]
  \centering
    \includegraphics[scale=0.4]{04-framework/activity_lifecycle.png} 
   \caption{Ciclo de vida de una Activity}
   \label{fig:umlFrameworkCore}
\end{figure}


\section{Fragments}
Un Fragment representa una sección modular y reusable de la IU de una Activity, el cual se puede agregar o quitar mientras la Activity se esté ejecutando (algo así como una "sub-Activity"). Se pueden combinar varios Fragments en una sola Activity para crear una IU multipanel y volver a usar un Fragment en diferentes Activities.


Un Fragment define y administra su propio diseño, su propio ciclo de vida, y recibe sus propios eventos de entrada. Un Fragment no es un componente de app, por lo que no es un punto de entrada a la app como lo es una Activity. Un Fragment no puede "vivir" por si mismo, debe ser hospedado por una Activity, y el ciclo de vida del Fragment se ve afectado directamente por el ciclo de vida de la Activity anfitriona. Por ejemplo, cuando la Activity está pausada, también lo están todos sus Fragments, y cuando la Activity se destruye, lo mismo ocurre con todos los Fragments. Sin embargo, mientras una Activity se está ejecutando (está en el estado 'running' del ciclo de vida), se puede manipular cada Fragment de forma independiente, por ejemplo, para agregarlo o quitarlo. Cuando se realiza una transacción de Fragments como esta, también se pueden agregar a una pila administrada por la Activity; cada entrada de la pila de la Activity es un registro de la transacción de Fragments realizada. La pila le permite al usuario invertir una transacción de Fragments (navegar hacia atrás) al presionar el botón Atrás del dispositivo móvil.

El siguiente diagrama muestra los estados mas importantes por los que pasa un Fragment. Los rectángulos representan métodos de respuesta a llamada que se pueden implementar para realizar operaciones cuando el Fragment se mueve entre un estado y otro. Los óvalos representan los estados más importantes por los que pasa un Fragment.


\begin{figure}[H]
  \centering
    \includegraphics[scale=0.4]{04-framework/fragment_lifecycle.png} 
   \caption{Ciclo de vida de un Fragment}
   \label{fig:umlFrameworkCore}
\end{figure}


Los Fragments introducen modularidad y reusabilidad en la IU de una Activity, permitiendo dividir la IU en módulos más discretos. Se pueden usar múltiples instancias de un mismo Fragment en la misma Activity, en varias Avtivities, o incluso dentro de otro Fragment. Por esta razón se deben diseñar los Fragments solamente con la lógica necesaria para manejar su propia IU, de forma que sean independientes, evitando la dependencia con otros Fragments.
Con esto en mente, las Activities son el lugar ideal para poner los elementos globales de la IU, como por ejemplo una barra de navegación. Por el contrario, los Fragments son mejor lugar para definir y manejar la IU de una sola pantalla, o una sección de la misma.

Por ejemplo, en una app que responde a varios tamaños de pantalla, la app debería mostrar en pantallas pequeñas una barra de navegación con íconos y una lista lineal con el contenido. En cambio, en pantallas más grandes, debería mostrar un área de navegación más detallada y el contenido en forma de grilla para aprovechar mejor el espacio.
Administrar todas estas variaciones en la Activity puede resultar engorroso. Separar los elementos de navegación del contenido hace este proceso más manejable. La Activity es responsable de mostrar la IU de navegación correcta mientras que el Fragment muestra el contenido con la disposición adecuada.

\begin{figure}[H]
  \centering
    \includegraphics[scale=0.4]{04-framework/fragment-screen-sizes.png} 
   \caption{Dos versiones de la misma pantalla en diferentes tamaños de pantalla}
   \label{fig:umlFrameworkCore}
\end{figure}


Para crear un Fragment, se debe crear una subclase Fragment (o una subclase existente de ella). La clase Fragment tiene un código que se asemeja bastante a una Activity. Contiene métodos de devolución de llamada similares a los de una actividad, como onCreate(), onStart(), onPause() y onStop(), aunque agrega otros para controlar cuando se crea y destruye su IU, o cuando se adjunta el Fragment a la Activity anfitriona.
\cite{androidDocs}


\section{Services}
Un Service es un componente de app que puede realizar operaciones de larga ejecución en segundo plano y que no proporciona una interfaz de usuario. Una vez iniciado, un Service puede continuar ejecutándose en segundo plano aún cuando el usuario cambie a otra app. Además, un componente puede enlazarse con un Service para interactuar con él e incluso realizar una comunicación entre procesos (IPC por sus siglas en inglés). Por ejemplo, un Service puede manejar transacciones de red, reproducir música, realizar I/O de archivos o interactuar con un ContentProvider, todo en segundo plano.
Un Service se ejecuta en el subproceso principal del proceso que lo contiene; el Service no crea su propio subproceso ni se ejecuta en un proceso separado (a menos que se especifique lo contrario), por lo que parar realizar un trabajo que consume más CPU u operaciones de bloqueo (como reproducción MP3 o funciones de red), se debe crear un subproceso nuevo dentro del Service para completar ese trabajo.

Hay tres tipos de Service:

\begin{itemize}
	\item \textbf{Primer plano:} Un Service en primer plano realiza una operación que el usuario puede notar. Por ejemplo, una aplicación de audio usa un Service en primer plano para reproducir una pista de audio. Los Services en primer plano deben mostrar una notificación para que el usuario sea consciente de que el Service se está ejecutando. Estos Services continúan ejecutándose incluso si el usuario deja de interactuar con la aplicación.
	
	
	\item \textbf{Segundo plano:} Un Service en segundo plano realiza una operación que el usuario no nota directamente. Por ejemplo, si una aplicación usa un Service para comprimir su almacenamiento, suele tratarse de un Service en segundo plano.
	
	
	\item \textbf{Enlace:} Un Service es de enlace cuando un componente de app se vincula a él llamando a bindService(). Un Service de enlace ofrece una interfaz cliente-servidor que permite que los componentes interactúen con el Service, envíen solicitudes, reciban resultados e incluso lo hagan en distintos procesos con la comunicación entre procesos (IPC). Un Service de enlace se ejecuta solamente mientras otro componente de aplicación está enlazado a él. Se pueden enlazar varios componentes con el mismo Service a la vez, pero cuando todos ellos se desenlazan, el Service se destruye.
\cite{androidDocs}		
\end{itemize}




\section{BroadcastReceivers}
Las apps de Android pueden enviar o recibir mensajes de emisión desde el sistema de Android y otras apps para Android, de forma similar al patrón de diseño de publicación y suscripción. Estas emisiones se envían cuando ocurre un evento de interés. Por ejemplo, el sistema Android envía emisiones cuando ocurren diferentes eventos del sistema, como cuando este se inicia, cuando el dispositivo comienza a cargarse o cuando se conecta a una red de Internet. Las apps también pueden enviar emisiones personalizadas, por ejemplo, para notificar a otras apps sobre algo que podría interesarles (como cuando se descargaron algunos datos nuevos).
Las apps pueden registrarse para recibir emisiones específicas. Cuando se envía una emisión, el sistema redirige automáticamente las emisiones a las apps que se suscribieron para recibir ese tipo de emisión particular.
Un BroadcastReceiver es un componente de app que permite recibir esos mensajes de emisión, incluso si la app no se está ejecutando en ese momento, ya que estos mensajes se generan fuera del flujo de usuario habitual.
\cite{androidDocs}


\begin{comment}

\section{Permisos}
[aca falta describir como funcionan los permisos para acceder a las funciones sensibles del dispositivo móvil en Android...]

\end{comment}


